# Phase 1 - Plan 01-05: Average Intensity Calculation

---
wave: 2
gap_closure: true
autonomous: true
depends_on: [01-04]
files_modified:
  - src/utils/dangerScoring.ts
  - src/components/Timeline/SceneTimeline.tsx
  - src/components/SceneTagModal/TimelineTags.tsx
  - src/utils/dangerScoring.test.ts
---

## Objective

Implement average intensity ratings calculation for scene tags, enabling community consensus view alongside maximum intensity. Display average intensity in timeline visualization to help users assess typical scene severity.

## Overview

**Gap Context:** Phase 1 verification identified that only maximum intensity is calculated and displayed. Users cannot determine community consensus or typical intensity—only worst-case scenarios are shown.

**Fix:** Add averageIntensity calculation to danger scoring (weighted by user count), display average alongside max in timeline aggregation windows, and add tests for averaging logic.

**Impact:** Completes "Average intensity ratings calculation" requirement from Phase 1 objectives. Provides users with both worst-case (max) and typical (average) intensity assessments.

## Acceptance Criteria

- [ ] calculateAverageIntensity function added to dangerScoring.ts
- [ ] Average intensity calculated per phobia (weighted by tag count)
- [ ] SceneTimeline displays both max and average intensity per window
- [ ] TimelineTags shows average intensity in individual tag aggregation
- [ ] Tests verify averaging logic with edge cases (single tag, multiple tags, zero tags)
- [ ] Average intensity uses same color coding as max (green/yellow/red)

<task name="add-average-intensity-calculation" id="task-1">
  <objective>Add averaging algorithm to dangerScoring.ts weighted by user count</objective>
  <acceptance>
    - [ ] src/utils/dangerScoring.ts updated with calculateAverageIntensity
    - [ ] Weighted average accounts for tag.count (multiple users tagging same scene)
    - [ ] Returns 0 when no tags exist
    - [ ] Handles edge cases (single tag, all tags same intensity)
    - [ ] Function exported for use in components
  </acceptance>
  <implementation>
Update src/utils/dangerScoring.ts:

**Add new function after calculateDangerScores:**
```typescript
/**
 * Calculate average intensity for a set of tags, weighted by user count
 * @param tags - Array of scene tags with intensity and count
 * @returns Average intensity (0-10) weighted by number of users per tag
 */
export function calculateAverageIntensity(tags: SceneTag[]): number {
  if (tags.length === 0) return 0;

  let totalIntensity = 0;
  let totalUsers = 0;

  tags.forEach(tag => {
    totalIntensity += tag.intensity * tag.count;
    totalUsers += tag.count;
  });

  return totalUsers > 0 ? totalIntensity / totalUsers : 0;
}

/**
 * Calculate average intensity per phobia for selected phobias
 * @param tags - Array of scene tags
 * @param selectedPhobias - Array of selected phobia IDs
 * @returns Record mapping phobia ID to average intensity
 */
export function calculateAverageIntensityByPhobia(
  tags: SceneTag[],
  selectedPhobias: string[]
): Record<string, number> {
  const byPhobia: Record<string, number> = {};

  selectedPhobias.forEach(phobiaId => {
    const phobiaTags = tags.filter(tag => tag.phobiaId === phobiaId);
    byPhobia[phobiaId] = calculateAverageIntensity(phobiaTags);
  });

  return byPhobia;
}
```

**Rationale:**
- **Weighted by count:** If 3 users tag a scene at intensity 8 and 1 user tags at intensity 2, average should be (8×3 + 2×1)/(3+1) = 6.5, not simple mean (8+2)/2 = 5
- **Returns 0 for empty:** Matches existing calculateDangerScores behavior
- **Separate per-phobia function:** Mirrors structure of calculateDangerScores for consistency

**TypeScript note:** SceneTag interface already has intensity: number and count: number fields, so no type changes needed.
  </implementation>
</task>

<task name="update-timeline-aggregation" id="task-2">
  <objective>Add average intensity to SceneTimeline 30-second aggregation windows</objective>
  <acceptance>
    - [ ] src/components/Timeline/SceneTimeline.tsx updated
    - [ ] AggregatedTag interface includes averageIntensity field
    - [ ] Aggregation logic calculates both max and average per window
    - [ ] UI displays "Max: X / Avg: Y" for each window
    - [ ] Timeline dot color reflects max intensity (existing behavior)
    - [ ] Average intensity shown in readable format (1 decimal place)
  </acceptance>
  <implementation>
Update src/components/Timeline/SceneTimeline.tsx:

**Update AggregatedTag interface (line 23-27):**
```typescript
interface AggregatedTag {
  timestamp: number; // bucket timestamp (30-second window)
  phobias: PhobiaInfo[];
  maxIntensity: number;
  averageIntensity: number; // NEW: weighted average across all tags in window
}
```

**Update aggregation logic (line 31-59):**
```typescript
import { calculateAverageIntensity } from '../../utils/dangerScoring';

const aggregated = useMemo(() => {
  const grouped: Record<number, AggregatedTag & { tagsInWindow: SceneTag[] }> = {};

  tags.forEach(tag => {
    const bucket = Math.round(tag.timestamp / 30) * 30;
    if (!grouped[bucket]) {
      grouped[bucket] = {
        timestamp: bucket,
        phobias: [],
        maxIntensity: 0,
        averageIntensity: 0,
        tagsInWindow: [], // Track tags for averaging
      };
    }

    // Track tag for average calculation
    grouped[bucket].tagsInWindow.push(tag);

    const phobia = grouped[bucket].phobias.find(p => p.id === tag.phobiaId);
    if (phobia) {
      phobia.count += tag.count;
    } else {
      grouped[bucket].phobias.push({
        id: tag.phobiaId,
        name: getPhobiaById(tag.phobiaId)?.name || 'Unknown',
        count: tag.count,
      });
    }

    grouped[bucket].maxIntensity = Math.max(grouped[bucket].maxIntensity, tag.intensity);
  });

  // Calculate average intensity for each window
  const result = Object.values(grouped).map(window => {
    const { tagsInWindow, ...rest } = window;
    return {
      ...rest,
      averageIntensity: calculateAverageIntensity(tagsInWindow),
    };
  });

  return result.sort((a, b) => a.timestamp - b.timestamp);
}, [tags]);
```

**Update UI display (line 80-105):**
```typescript
<TimelineContent>
  <div style={{
    padding: '10px',
    background: 'rgba(255, 255, 255, 0.05)',
    borderRadius: '4px',
    marginBottom: '10px',
  }}>
    <div style={{
      fontWeight: 'bold',
      marginBottom: '8px',
      fontSize: '1rem',
    }}>
      {formatTimestamp(item.timestamp)}
    </div>
    {/* NEW: Display max and average intensity */}
    <div style={{
      fontSize: '0.85rem',
      opacity: 0.7,
      marginBottom: '8px',
    }}>
      Max: {item.maxIntensity}/10 • Avg: {item.averageIntensity.toFixed(1)}/10
    </div>
    {item.phobias.map(p => (
      <div key={p.id} style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '4px' }}>
        {p.name} ({p.count} user{p.count > 1 ? 's' : ''})
      </div>
    ))}
  </div>
</TimelineContent>
```

**Visual design:**
- Max and average shown together on same line (compact)
- Smaller font (0.85rem) and lower opacity (0.7) to avoid overwhelming timestamp
- Average rounded to 1 decimal (e.g., "7.3/10") for precision without clutter
- Timeline dot color still based on max (red dot = high max intensity alert)
  </implementation>
</task>

<task name="update-timeline-tags-summary" id="task-3">
  <objective>Add average intensity summary to TimelineTags component header</objective>
  <acceptance>
    - [ ] src/components/SceneTagModal/TimelineTags.tsx updated
    - [ ] Timeline Overview section shows overall average intensity
    - [ ] Calculated across all tags in entire movie (not per window)
    - [ ] Displayed prominently above timeline visualization
    - [ ] Shows both max and average for comparison
  </acceptance>
  <implementation>
Update src/components/SceneTagModal/TimelineTags.tsx:

**Add calculation in component body (after tags.length check):**
```typescript
import { calculateAverageIntensity } from '../../utils/dangerScoring';

export function TimelineTags({ tags, onRemoveTag }: TimelineTagsProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  // Calculate overall statistics
  const maxIntensity = tags.length > 0
    ? Math.max(...tags.map(t => t.intensity))
    : 0;
  const averageIntensity = calculateAverageIntensity(tags);

  if (tags.length === 0) {
    // ... existing empty state
  }

  return (
    <div>
      {/* Timeline Overview */}
      <section style={{ marginBottom: '30px' }}>
        <h3 style={{
          fontSize: '1.3rem',
          marginBottom: '15px',
          borderBottom: '2px solid rgba(255, 255, 255, 0.1)',
          paddingBottom: '8px',
        }}>
          Timeline Overview
        </h3>

        {/* NEW: Overall intensity statistics */}
        <div style={{
          padding: '15px',
          background: 'rgba(255, 255, 255, 0.05)',
          borderRadius: '4px',
          marginBottom: '15px',
          display: 'flex',
          gap: '20px',
          justifyContent: 'center',
        }}>
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: '0.85rem', opacity: 0.7, marginBottom: '5px' }}>
              Maximum Intensity
            </div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>
              {maxIntensity}/10
            </div>
          </div>
          <div style={{
            width: '1px',
            background: 'rgba(255, 255, 255, 0.2)'
          }} />
          <div style={{ textAlign: 'center' }}>
            <div style={{ fontSize: '0.85rem', opacity: 0.7, marginBottom: '5px' }}>
              Average Intensity
            </div>
            <div style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>
              {averageIntensity.toFixed(1)}/10
            </div>
          </div>
        </div>

        <SceneTimeline tags={tags} />
      </section>
      {/* ... rest of component */}
    </div>
  );
}
```

**Design rationale:**
- **Prominent placement:** Above timeline so users see overall stats first
- **Side-by-side comparison:** Max vs Avg helps users understand if few high-intensity tags skew perception
- **Large numbers:** 1.5rem font size makes stats easily scannable
- **Subtle container:** Light background distinguishes stats from timeline without being distracting
  </implementation>
</task>

<task name="add-averaging-tests" id="task-4">
  <objective>Add tests for average intensity calculation logic</objective>
  <acceptance>
    - [ ] src/utils/dangerScoring.test.ts created
    - [ ] Test: Average is 0 when no tags exist
    - [ ] Test: Average equals intensity when single tag exists
    - [ ] Test: Average correctly weighted by user count
    - [ ] Test: Average handles mixed intensities correctly
    - [ ] Test: Per-phobia averaging works correctly
    - [ ] All tests pass
  </acceptance>
  <implementation>
Create src/utils/dangerScoring.test.ts:

```typescript
import {
  calculateAverageIntensity,
  calculateAverageIntensityByPhobia,
  calculateDangerScores
} from './dangerScoring';
import type { SceneTag } from '../types/phobia';

describe('calculateAverageIntensity', () => {
  it('returns 0 when no tags exist', () => {
    expect(calculateAverageIntensity([])).toBe(0);
  });

  it('returns tag intensity when single tag exists', () => {
    const tags: SceneTag[] = [
      { phobiaId: 'arachnophobia', intensity: 7, timestamp: 120, notes: '', count: 1 }
    ];
    expect(calculateAverageIntensity(tags)).toBe(7);
  });

  it('calculates simple average when all tags have count=1', () => {
    const tags: SceneTag[] = [
      { phobiaId: 'arachnophobia', intensity: 6, timestamp: 120, notes: '', count: 1 },
      { phobiaId: 'arachnophobia', intensity: 8, timestamp: 180, notes: '', count: 1 },
      { phobiaId: 'arachnophobia', intensity: 10, timestamp: 240, notes: '', count: 1 },
    ];
    // (6 + 8 + 10) / 3 = 8
    expect(calculateAverageIntensity(tags)).toBe(8);
  });

  it('calculates weighted average based on user count', () => {
    const tags: SceneTag[] = [
      { phobiaId: 'arachnophobia', intensity: 8, timestamp: 120, notes: '', count: 3 },
      { phobiaId: 'arachnophobia', intensity: 2, timestamp: 180, notes: '', count: 1 },
    ];
    // (8×3 + 2×1) / (3+1) = 26/4 = 6.5
    expect(calculateAverageIntensity(tags)).toBe(6.5);
  });

  it('handles tags with zero count gracefully', () => {
    const tags: SceneTag[] = [
      { phobiaId: 'arachnophobia', intensity: 5, timestamp: 120, notes: '', count: 0 },
    ];
    expect(calculateAverageIntensity(tags)).toBe(0);
  });
});

describe('calculateAverageIntensityByPhobia', () => {
  it('returns 0 for each phobia when no tags exist', () => {
    const result = calculateAverageIntensityByPhobia([], ['arachnophobia', 'acrophobia']);
    expect(result.arachnophobia).toBe(0);
    expect(result.acrophobia).toBe(0);
  });

  it('calculates average per phobia correctly', () => {
    const tags: SceneTag[] = [
      { phobiaId: 'arachnophobia', intensity: 8, timestamp: 120, notes: '', count: 2 },
      { phobiaId: 'arachnophobia', intensity: 6, timestamp: 180, notes: '', count: 1 },
      { phobiaId: 'acrophobia', intensity: 4, timestamp: 240, notes: '', count: 1 },
      { phobiaId: 'acrophobia', intensity: 10, timestamp: 300, notes: '', count: 1 },
    ];

    const result = calculateAverageIntensityByPhobia(
      tags,
      ['arachnophobia', 'acrophobia']
    );

    // arachnophobia: (8×2 + 6×1) / (2+1) = 22/3 ≈ 7.33
    expect(result.arachnophobia).toBeCloseTo(7.33, 2);
    // acrophobia: (4×1 + 10×1) / (1+1) = 14/2 = 7
    expect(result.acrophobia).toBe(7);
  });

  it('ignores non-selected phobias', () => {
    const tags: SceneTag[] = [
      { phobiaId: 'arachnophobia', intensity: 8, timestamp: 120, notes: '', count: 1 },
      { phobiaId: 'claustrophobia', intensity: 9, timestamp: 180, notes: '', count: 1 },
    ];

    const result = calculateAverageIntensityByPhobia(tags, ['arachnophobia']);

    expect(result.arachnophobia).toBe(8);
    expect(result.claustrophobia).toBeUndefined();
  });
});

describe('calculateDangerScores (existing tests for max)', () => {
  it('uses max intensity not average for danger scores', () => {
    const tags: SceneTag[] = [
      { phobiaId: 'arachnophobia', intensity: 3, timestamp: 120, notes: '', count: 5 },
      { phobiaId: 'arachnophobia', intensity: 9, timestamp: 180, notes: '', count: 1 },
    ];

    const result = calculateDangerScores(tags, ['arachnophobia']);

    // Average would be (3×5 + 9×1)/(5+1) = 24/6 = 4
    // But danger score should use max = 9
    expect(result.byPhobia.arachnophobia).toBe(9);
    expect(result.overall).toBe(9);
  });
});
```

**Test strategy:**
- **Edge cases:** Empty arrays, single tags, zero counts
- **Weighted averaging:** Verify count multiplier works correctly
- **Per-phobia separation:** Ensure averaging doesn't cross phobia boundaries
- **Danger scores unchanged:** Confirm max-based scoring still works (average doesn't replace it)

**Run tests:**
```bash
npm test -- dangerScoring.test.ts
```
  </implementation>
</task>

## Must-Haves (Goal-Backward Verification)

Phase goal: Build core phobia-aware browsing + danger scores + tagging framework

This plan must deliver:
- [x] calculateAverageIntensity function with weighted averaging
- [x] calculateAverageIntensityByPhobia for per-phobia averaging
- [x] SceneTimeline shows both max and average per 30-second window
- [x] TimelineTags shows overall max and average statistics
- [x] Tests verify averaging logic with edge cases
- [ ] Danger scores still use max intensity (existing behavior preserved)
- [ ] Plan 01-04 wired danger scores to tags (dependency)

**Gap Closure:** This plan closes the "Average intensity ratings calculation" gap identified in 01-VERIFICATION.md. After execution, users can assess both worst-case (max) and typical (average) scene intensity based on community consensus.

**Phase 1 Complete:** With Plans 01-04 and 01-05 executed, all 8 must-have requirements from Phase 1 are satisfied:
1. ✓ TMDB API integration
2. ✓ Browse popular movies
3. ✓ Search functionality
4. ✓ Movie detail page
5. ✓ Personalized danger scores (01-04)
6. ✓ Scene tagging UI
7. ✓ View individual tags
8. ✓ Average intensity calculation (01-05)
